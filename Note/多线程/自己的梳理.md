###线程的发起和状态



 1. 创建线程的方法
  
    * extends Thread
      
    * implements Runnable  //启动线程的方法必须是start(). 不要被run方法误导
 2. 线程完成：
  
      * run() 方法执行完成
        
      * 抛出一个未处理的异常导致线程的提前结束
        
 3. 线程的状态
    * 新创建
        * 被创建但是没有调用Start()方法
    * 可运行(Runable)   
        * 线程是否在运行完全是由CPU来决定
        * 没有运行的状态 不由语言来决定
    * 被阻塞(Blocking)
        * 阻塞 线程被锁阻塞
    * 等待/记时等待(Waiting)
        * 等待某些条件完成
    * 被终止  
        * 线程执行完毕
        
 4. 线程的优先级
 
    * `setPriority();`
   
    * 成员变量优先级,范围1-10之间，缺省为5  //不一定发挥重要
   
 5. Daemon 线程
 
    * 守护型线程(GC 线程) 程序里面没有非Daemon 线程时, java程序就会退出。一般用不上。
    
    * `setDaemo(true)`  设置成守护线程 守护线程的finally的代码不一定执行
          
 6. 常用方法
 
    * `run()` and `start()`     
    
    * run是普通方法,start才是启动线程的方法。  
    
    * `sleep()` 不释放锁
    
    * `yield()` 当前线程出让cpu的占有权 下一时刻仍然可能被选中 也不会释放锁
    
    * `wait()` 调用以前必须是要拿到锁否则会抛异常 调用之后释放锁  
    
    * `notify()` 谨慎使用   每次只唤醒一个随机线程  请使用 `notifyall()`
  
  7. 线程之间的协作和通讯
      
     * synchronized   //TODO
     
     * volatile 
     
          >  多线程同时访问一个共享变量的时候
            
          >  每个线程的工作内存都有这个变量的一个拷贝
            
          > 变量本身还是存在保存在共享内存中
          
          > volatile 修饰字段，对这个变量的访问必须要从共享内存中刷新一次。
          
          >最新修改的写会共享内存,保证字段的可见性。是线程不安全的。
          
 8. 等待通知机制
 
    * 等待方的原则
    
        * 获取对象锁
        
        * 如果条件不满足,调用对象的wait()方法,被通知后依然要检查条件是否满足
        
        * 条件满足以后,才能执行业务的相关逻辑
        
                Synchronized(Object){
                
                        While(条件不满足){
                            Object.wait();
                        }
                        
                        业务逻辑处理
                 }
                 
    * 通知方的原则
     
         * 同样要获取对象锁
         
         * 改变条件
         
         * 通知所有在等待的线程
         
                 Synchronized(Object){
                 
                        业务逻辑处理 改变条件
                        
                        Object.notify/notifyAll();
                         
                  }                
    * 管道输入输入流 1对1 比较受限
    
    * join 方法
        * 线程A,执行了 threar.join(),线程A等待thread 线程终止了以后, A 在join 后面的语句才会继续执行;              